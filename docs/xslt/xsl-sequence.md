---
description: Используется для построения произвольных последовательностей. Он может выбирать любую последовательность узлов и/или атомарных значений и, по сути, добавляет их к результирующей последовательности
---

# xsl:sequence

Используется для построения произвольных последовательностей. Он может выбирать любую последовательность узлов и/или атомарных значений и, по сути, добавляет их к результирующей последовательности.

_Доступен в XSLT 2.0 и более поздних версиях. Доступен во всех изданиях Saxon._

-   **Категория**: инструкция
-   **Содержимое**: _sequence-constructor_
-   **Допустимые родительские элементы**: любой элемент XSLT, модель содержимого которого - _sequence-constructor_; любой литеральный элемент результата

## Атрибуты

`select?`
: _expression_
: Определяет вход. Обязательный атрибут в XSLT 2.0, но в XSLT 3.0 (и реализованном начиная с Saxon 9.5) вход может быть указан либо атрибутом `select`, либо вложенным конструктором последовательности.

## Подробности

Элемент `xsl:sequence` может использоваться для создания любой последовательности узлов и/или атомарных значений. Они включаются в последовательность результатов напрямую. В отличие от [`xsl:copy-of`](xsl-copy-of.md), копирование не производится.

Наиболее распространенное использование - возврат результата из функции (см. пример 1).

Есть еще два интересных сценария использования. Первый - это копирование атомарных значений в дерево (см. пример 2). Второй, более важный, - построение переменной с порядковым значением (см. пример 3). Переменная является последовательно-оценочной, если элемент привязки переменной (например, [`xsl:variable`](xsl-variable.md)) имеет непустое содержимое, атрибут as и не имеет атрибута `select`.

Если узлы строятся внутри переменной с порядковым значением, они будут _без_ родителей. Пример переменной с последовательным значением, содержащей узлы без родителей, приведен в примере 4.

## Примеры

### Пример 1

Возвращение результата из функции:

```xslt
<xsl:function name="f:increment" as="xs:integer">
    <xsl:param name="in" as="xs:integer"/>
    <xsl:sequence select="$in + 1"/>
</xsl:function>
```

### Пример 2

Копирование атомарных значений в дерево:

```xslt
<e>
    <xsl:sequence select="1 to 5"/>
    <br/>
    <xsl:sequence select="6 to 10"/>
</e>
```

Это приводит к выводу `<e>1 2 3 4 5<br/>6 7 8 9 10</e>`.

### Пример 3

Конструирование переменной с последовательным значением:

```xslt
<xsl:variable name="seq" as="xs:integer *">
    <xsl:for-each select="1 to 5">>
       <xsl:sequence select=". * ."/>
    </xsl:for-each/>
</xsl:variable>
```

В качестве значения переменной получается последовательность (`1, 4, 9, 16, 25`).

### Пример 4

Создание переменной, значением которой является последовательность из трех атрибутов без родителей:

```xslt
<xsl:variable name="seq" as="attribute() *">
    <xsl:attribute name="a">10</xsl:attribute>
    <xsl:attribute name="b">20</xsl:attribute>
    <xsl:attribute name="a">30</xsl:attribute>
</xsl:variable>
```

Вполне законно иметь два атрибута в последовательности с одинаковыми именами; конфликта не возникает до тех пор, пока не будет сделана попытка добавить их оба в один и тот же элемент. Атрибуты могут быть добавлены в элемент с помощью `<xsl:copy-of select="$seq"/>` в инструкции [`xsl:element`](xsl-element.md) или в буквальном элементе результата. На этом этапе действует обычное правило: если атрибуты дублируются, побеждает последний.

## Ссылки

-   [XSLT 2.0 Specification](http://www.w3.org/TR/xslt20/#element-sequence)
-   [XSLT 3.0 Specification](http://www.w3.org/TR/xslt-30/#element-sequence)
-   [Saxon](https://www.saxonica.com/html/documentation/xsl-elements/sequence.html)

## См. также

-   [`xsl:copy-of`](xsl-copy-of.md)
-   [`xsl:function`](xsl-function.md)
-   [`xsl:template`](xsl-template.md)
